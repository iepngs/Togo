package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"text/template"

	"gopkg.in/yaml.v2"
)

var (
	help         bool
	lint         bool
	create       bool
	gen          string
	yamlFilePath string
)

type Func struct {
	Name   string `yaml:"name"`
	Method string `yaml:"method"`
}

type Modules struct {
	Name string `yaml:"name"`
	Func []Func `yaml:"func"`
}

type AutoGenerated struct {
	Modules Modules `yaml:"modules"`
}

func init() {
	flag.StringVar(&gen, "g", "all", "generate [all,model,repo,usecase,handler]")
	flag.BoolVar(&help, "h", false, "help")
	flag.BoolVar(&lint, "l", false, "lint")
	flag.BoolVar(&create, "n", false, "new yaml file")
	flag.StringVar(&yamlFilePath, "y", "", "yaml file path")
	flag.Usage = usage
}

func usage() {
	_, _ = fmt.Fprintf(os.Stderr, `togo_gen version: 0.0.1
Usage: togo_gen [-hfl] [-y yaml_filename]

Options:
`)
	flag.PrintDefaults()
}

func main() {
	flag.Parse()

	// 检查是否需要输出帮助
	if help {
		flag.Usage()
	} else {
		//检测文件是否存在
		if yamlFilePath == "" {
			_, _ = fmt.Fprintf(os.Stderr, `yaml file not exists...`)
			return
		}
		//l和g是能取其一
		if lint {
			_, err := Unmarshal(yamlFilePath)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, err.Error())
			}
			_, _ = fmt.Fprintf(os.Stderr, "ok!")
		} else if create {
			err := CreateNewConfigFile(yamlFilePath)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, err.Error())
				return
			}
			_, _ = fmt.Fprintf(os.Stderr, "ok!")
		} else {
			//检测生成类型
			conf, err := Unmarshal(yamlFilePath)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, err.Error())
				return
			}
			err = Gen(gen, conf)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, err.Error())
				return
			}
			_, _ = fmt.Fprintf(os.Stderr, "ok!")
		}

	}

}

func Gen(typ string, conf *AutoGenerated) error {
	switch typ {
	case "all":
		err := GenModel(conf.Modules)
		if err != nil {
			return err
		}
		err = GenRepo(conf.Modules)
		if err != nil {
			return err
		}
		err = GenUseCase(conf.Modules)
		if err != nil {
			return err
		}
		err = GenHandler(conf.Modules)
		if err != nil {
			return err
		}
	case "model":
		err := GenModel(conf.Modules)
		if err != nil {
			return err
		}
	case "repo":
		err := GenRepo(conf.Modules)
		if err != nil {
			return err
		}
	case "usecase":
		err := GenUseCase(conf.Modules)
		if err != nil {
			return err
		}
	case "handler":
		err := GenHandler(conf.Modules)
		if err != nil {
			return err
		}
	}

	return nil
}

func GenModel(m Modules) error {
	var filepath = "../models/" + m.Name + ".go"
	if ok, err := FilePathExist(filepath); err != nil {
		return err
	} else if !ok {
		f, err := os.OpenFile(filepath, os.O_CREATE|os.O_RDWR, 0777)
		if err != nil {
			return err
		}
		defer f.Close()
		tmpl, err := template.ParseFiles("./tpl/model.tpl")
		if err != nil {
			return err
		}
		return tmpl.Execute(f, m)
	}

	_, _ = fmt.Fprintf(os.Stderr, "no file create: file path exist!")
	return nil
}

func GenUseCase(m Modules) error {
	var filepath = "../usecases/"+m.Name+".go"
	if ok,err := FilePathExist(filepath); err != nil {
		return err
	}else if !ok {
		//文件不存在 创建
		f, err := os.OpenFile(filepath, os.O_CREATE|os.O_RDWR, 0777)
		if err != nil {
			return err
		}
		defer f.Close()
		tmpl, err := template.ParseFiles("./tpl/usecase.tpl")
		if err != nil {
			return err
		}
		err = tmpl.Execute(f, m)
		if err != nil {
			return err
		}

		//追加interface
		filepath = "../usecases/interface.go"
		f, err = os.OpenFile(filepath, os.O_RDWR|os.O_APPEND, 0777)
		if err != nil {
			return err
		}
		tmpl, err = template.ParseFiles("./tpl/usecase_interface.tpl")
		if err != nil {
			return err
		}
		return tmpl.Execute(f, m)
	}
	_, _ = fmt.Fprintf(os.Stderr, "no file create: file path exist!")
	return nil
}

func GenHandler(m Modules) error {
	var filepath = "../gateway/handler/"+m.Name+".go"
	if ok,err := FilePathExist(filepath); err != nil {
		return err
	}else if !ok {
		//文件不存在 创建
		f, err := os.OpenFile(filepath, os.O_CREATE|os.O_RDWR, 0777)
		if err != nil {
			return err
		}
		defer f.Close()
		tmpl, err := template.ParseFiles("./tpl/handler.tpl")
		if err != nil {
			return err
		}
		return tmpl.Execute(f, m)
	}
	_, _ = fmt.Fprintf(os.Stderr, "no file create: file path exist!")
	return nil
}

func GenRepo(m Modules) error {
	// 检测repo 的 filename.go
	var filepath = "../repos/"+m.Name+".go"
	if ok,err := FilePathExist(filepath); err != nil {
		return err
	}else if !ok {
		//文件不存在 创建
		f, err := os.OpenFile(filepath, os.O_CREATE|os.O_RDWR, 0777)
		if err != nil {
			return err
		}
		defer f.Close()
		tmpl, err := template.ParseFiles("./tpl/repo.tpl")
		if err != nil {
			return err
		}
		err = tmpl.Execute(f, m)
		if err != nil {
			return err
		}

		//追加interface
		filepath = "../repos/interface.go"
		f, err = os.OpenFile(filepath, os.O_RDWR|os.O_APPEND, 0777)
		if err != nil {
			return err
		}
		tmpl, err = template.ParseFiles("./tpl/repo_interface.tpl")
		if err != nil {
			return err
		}
		return tmpl.Execute(f, m)
	}
	_, _ = fmt.Fprintf(os.Stderr, "no file create: file path exist!")
	return nil
}

func CreateNewConfigFile(path string) error {
	if ok, err := FilePathExist(path); err != nil {
		return err
	} else if !ok {
		f, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0777)
		if err != nil {
			return err
		}
		defer f.Close()
		var tempFile = &AutoGenerated{
			Modules: Modules{
				Name: "User",
				Func: []Func{
					{
						Name:   "Login",
						Method: "POST",
					},
					{
						Name:   "Register",
						Method: "GET",
					},
				},
			},
		}
		body, err := yaml.Marshal(&tempFile)
		if err != nil {
			return err
		}
		_, err = f.Write(body)
		return err
	}
	_, _ = fmt.Fprintf(os.Stderr, "no file create: file path exist!")
	return nil
}

func Unmarshal(file string) (*AutoGenerated, error) {
	yamlFile, err := ioutil.ReadFile(file)
	if err != nil {
		return nil, err
	}
	var conf = new(AutoGenerated)
	err = yaml.Unmarshal(yamlFile, conf)
	if err != nil {
		return nil, err
	}
	return conf, nil
}

func FilePathExist(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}
